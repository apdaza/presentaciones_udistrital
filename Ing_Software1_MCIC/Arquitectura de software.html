<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="../estilos/estilos.css">
  </head>
  <body>
    <textarea id="source">
      name: inverse
      layout: true
      class: center, middle, inverse
      ---
      template: inverse
      # Arquitectura de software
      ---
      layout: false
      # Arquitectura de software
      
      ## Contenidos
      - Modelado de software.
      - Calidad de software
      - Arquitectura de software.
       - Características de la arquitectura de software.
       - Objetivos de la arquitectura de software.
       - Importancia de la arquitectura de software.
       - El arquitecto de software.
       - Desafíos de la arquitectura de software.
       - Proceso de modelado de arquitectura de software.
      - Evolución de la arquitectura de software.
       - Arquitectura monolítica
       - Arquitectura Cliente / Servidor
       - Arquitectura N-capas
       - Arquitectura Orientada a Servicios
       - Arquitecturas basadas en microservicios
      ---
      # Modelado de software.

      ![RN](./media/funcionales_vs_calidad.png)

      >> Si lo único que importa es la funcionalidad, cualquier software monolítico serviría

      ---
      # Modelado de software.
      ## Gestión de requerimientos
      ![RN](./media/gestion_requerimientos.png)

      ---
      # Modelado de software.

      ___Qué pasa con:___

      - la modificabilidad
      - la interoperabilidad
      - la disponibilidad
      - la seguridad 
      - la predictibilidad 
      - la portabilidad 
      ….
      >> Los atributos de calidad del software y su caracterización son esenciales.

      ---
      # Modelado de software.

      > Si no se desarrolla __explícitamente__ la arquitectura, se obtendrá una de todas formas, pero puede que lo que se obtenga no satisfaga las necesidades! 

      .text-column[
      - Descripciones operacionales
      - Requisitos funcionales de alto nivel
      - Sistemas legados
      ![RN](./media/flecha_vertical.png)
      - Diseño detallado 
      - Implementación
      ]
      .img-column[
      ![RN](./media/milagro.png)
      ]

      ---
      # Modelado de software.

      __Atributos de calidad:__
      - Rara vez se capturan como parte de la especificación de requisitos.
      - Generalmente son sólo vagamente comprendidos. 
      - Frecuentemente pobremente articulados.
      - La funcionalidad es en gran medida ortogonal a los requisitos de calidad.
      - Los sistemas se descomponen en elementos para lograr variados propósitos, más allá de la funcionalidad.

      ---
      # Calidad de software

      > Es uno de los problemas fundamentales del software y la computación.
      
      Se puede definir como:
      
      - “conjunto de cualidades que caracterizan el software y que determinan su utilidad y existencia.”
      - “sinónimo de eficiencia, flexibilidad, corrección, confiabilidad, mantenibilidad, portabilidad, usabilidad, seguridad e integridad.”

      > La calidad del software es medible y varía de un sistema a otro o de un programa a otro.
      
      Puede evaluarse:
      - al nivel de "cero fallas".
      - sólo a nivel de funcionalidad.
      - a nivel de su confiabilidad, mantenibilidad y flexibilidad.
      
      > Debe controlarse durante todas las etapas del ciclo de vida del software.

      ---
      # Arquitectura de software

      - Define la ___estructura general del sistema___, entendiendo estructura como los componentes que nacen de la abstracción del sistema, que cumple funciones específicas, e interactúan entre sí con un comportamiento definido.

      - Puede ser vista como la ___estructura del sistema en función de la definición de los componentes y sus interacciones___, considerando los requerimientos y restricciones del sistema, junto a los argumentos que justifiquen que la estructura definida satisface los requerimientos del sistema.

      - Una estructura compuesta por ___componentes de software___ y ___reglas que caracterizan la interacción entre estos componentes___.
      
      - Un ___conjunto de elementos arquitecturales___ ( de procesamiento, de datos y de conexión) que tienen una forma particular. 
      
      - Una ___colección de componentes___ en conjunto con una descripción de las interacciones entre estos componentes, es decir, de los conectores.

      ---
      # Arquitectura de software
   
      - Una ___estructura organizacional de un sistema de software___ que incluye componentes, conexiones, restricciones y una exposición razonada de los requerimientos que ella satisface.
      
      - Se refiere a grandes rasgos, a una ___vista del sistema___ que incluye los componentes principales del mismo, la conducta de esos componentes según se le percibe desde el resto del sistema y las formas en que los componentes interactúan y se coordinan para alcanzar la misión del sistema. 
      
      - Tiene que ver con el diseño y la implementación de estructuras de software de ___alto nivel___. 

      - Es el resultado de ___ensamblar un cierto número de elementos arquitectónicos___ de forma adecuada para ___satisfacer los requerimientos funcionales y no funcionales___.
      
      ---
      # Arquitectura de software

      - La IEEE 1471-2000 la define como la ___organización fundamental de un sistema___ encarnada en sus componentes, las relaciones entre ellos, el ambiente y los principios que orientan su diseño y evolución.
      
      - Se refiere a la ___especificación de la estructura del sistema___, entendida como la organización de ___componentes___ y ___relaciones entre ellos___; los requerimientos que debe satisfacer el sistema y las restricciones a las que está sujeto, así como las propiedades no funcionales del sistema y su impacto sobre la calidad del mismo; las reglas y decisiones de diseño que gobiernan esta estructura y los argumentos que justifican las decisiones tomadas.

      ---
      # Arquitectura de software

      .img-column[
      ![RN](./media/puente.png)
      ]
      .text-column[
      - La arquitectura de software puede considerarse como el ___“puente”___ entre los requerimientos del sistema y la implementación. 
      
      - La Arquitectura de software asocia las capacidades del sistema especificadas en el requerimiento con los componentes del sistema que habrán de implementarla. 
      ]

      ---
      # Arquitectura de software

      ![RN](./media/arquitectura_ciclo_vida.png)

      ---
      # Características de la arquitectura de software

      - Parte del diseño de software.
      - Nivel del diseño de software donde se definen la estructura y propiedades globales del sistema.
      - Incluye sus componentes, las propiedades observables de dichos componentes y las relaciones que se establecen entre ellos. 
      - Representación de alto nivel de la estructura del sistema describiendo las partes que lo integran.
      - Puede incluir los patrones que supervisan la composición de sus componentes y las restricciones al aplicar los patrones.
      - Trata aspectos del diseño y desarrollo que no pueden tratarse adecuadamente dentro de los módulos que forman el sistema.
      - Toda aplicación tiene una arquitectura, aunque no sea explícita.

      ---
      # Características de la arquitectura de software

      - Hace explícito con rigor el repertorio de técnicas, patrones y expresiones para estructurar sistemas de software complejos.
      - Incluye modelos, lenguajes y herramientas para la descripción y desarrollo práctico de arquitecturas de software.
      - La arquitectura de software no se ocupa de:
       - Diseño detallado.
       - Diseño de algoritmos.
       - Diseño de estructuras de datos.
      
      ---
      # Objetivos de la arquitectura de software
      
      - Comprender (abstracción) y mejorar la estructura de las aplicaciones complejas.
      - Reutilizar dicha estructura (o partes de ella) para resolver problemas similares.
      - Analizar la corrección de la aplicación y su grado de cumplimiento respecto a los requisitos iniciales.
      - Permitir el estudio de algunas propiedades específicas del dominio.
      - Planificar la evolución de la aplicación, identificando las partes mutables e inmutables de la misma, así como los costos de los posibles cambios.
      - Permitir la adaptación al cambio por composición, reconfiguración, reutilización, escalabilidad, mantenibilidad, etc.
      - Presentar la organización a alto nivel del sistema, incluyendo aspectos como: la descripción, el análisis de propiedades relativas a su estructura y control global, los protocolos de comunicación, los protocolos de sincronización utilizados, la distribución física del sistema y sus componentes, etc.
      
      ---
      # Importancia de la arquitectura de software

      ![RN](./media/arquitectura_importancia.png)

      ---
      # Importancia de la arquitectura de software

      - La necesidad del manejo de la arquitectura de un sistema de software nace con los sistemas de mediana o gran envergadura y con la tendencia al crecimiento de los sistemas en cuanto al volumen de datos, códigos y aspectos funcionales y no funcionales.
      - En la medida que los sistemas de software crecen en complejidad, bien sea por número de requerimientos o por el impacto de los mismos, se hace necesario establecer medios para el manejo de esta complejidad. 
      - Incrementos en la evolutividad de los sistemas de software en cuanto a partes o componentes del negocio (globalizaciones, concentraciones, reorganizaciones, competencia, etc) y de la plataformas de ejecución.
      - Incremento de la heterogeneidad de los sistemas en cuanto a lenguajes y paradigmas, manejadores de datos y protocolos de acceso, sistemas operativos, plataformas intermediarias y sistemas operativos.
      
      ---
      # Importancia de la arquitectura de software

      - Permite descomponer el sistema en piezas.
      - Los componentes definidos agrupan aspectos específicos del sistema.
      - Es producto de un proceso de abstracción.
      - Organiza y constituye la base de la solución de un problema.
      

      ---
      # Importancia de la arquitectura de software

      ![RN](./media/complejidad.png)

      ---
      # Importancia de la arquitectura de software

      Evolución acelerada del Hardware:
      
      - Incremento constante de la capacidad de operación (Ordenadores potentes).
      - Miniaturización (Equipos pueden llevarse en el bolsillo)
      - Reducción de costes para la producción de hardware.
      - Avance de las comunicaciones entre sistemas. (hiperconectados)
      - Incremento de tasa de surgimiento de tecnologías (coexistencia de nuevas y viejas tecnologías)

      ---
      # Importancia de la arquitectura de software

      La medida en que un sistema alcanza sus requisitos de calidad depende de las decisiones de arquitectura:
      
      - la arquitectura es crítica para alcanzar los atributos de calidad;
      - las cualidades del producto deben diseñarse como parte de la arquitectura;
      - un cambio en la estructura que mejora una cualidad suele afectar las otras cualidades;
      - la arquitectura sólo puede permitir, no garantizar, que cualquier requisito de calidad se alcance.

      ---
      # El arquitecto de software

      - Es el responsable por la arquitectura de software lo que incluye las decisiones técnicas que rigen sobre el diseño e implementación del proyecto.
      - Esto típicamente incluye identificar y documentar los aspectos arquitecturalmente significantes del sistema, incluidos los requerimientos, diseño, implementación y vistas del despliegue del sistema.
      - Es responsable por proveer razones fundamentales por las decisiones técnicas tomadas, balancear los intereses de varios stakeholders (interesados), manejar los riesgos técnicos del proyecto y asegurar que las decisiones sean efectivamente comunicadas, validadas y adoptadas.
      
      ---
      # El arquitecto de software

      ![RN](./media/arquitecto.png)

      ---
      # El arquitecto de software

      ![RN](./media/arquitecto01.png)

      ---
      # Desafíos de la arquitectura de software

      - ¿Qué significan con precisión atributos de calidad tales como modificabilidad, seguridad, performance y confiabilidad?
      - ¿Cómo se estructura el sistema de modo que tenga estas cualidades deseadas?
      - ¿Se puede analizar el sistema para determinar si tiene estas cualidades?
      - ¿Cuán temprano puede realizarse este análisis?
      - ¿Cómo se sabe si una arquitectura de software es apropiada para un sistema sin tener que construir el sistema primero? 
      - ¿Están realmente comprendidos los objetivos organizacionales y las propiedades del sistema requeridas por el negocio y estos están articulados entre sí?
      
      ---
      # Desafíos de la arquitectura de software

      - Los arquitectos deben identificar e involucrar activamente a los interesados de modo de:
       - comprender las restricciones reales del sistema.
       - administrar las expectativas de los interesados.
       - negociar las prioridades del sistema.
       - tomar decisiones de compromiso. 

      ---
      # Proceso de modelado de arquitectura de software 

      ![RN](./media/modelado_arquitectura.png)

      ---
      # Proceso de modelado de arquitectura de software 

      - __Definir los requerimientos:__ Involucra crear un modelo desde los requerimientos que guiarán el diseño de la arquitectura basado en los atributos de calidad esperados
      - __Diseño de la Arquitectura:__ Involucra definir la estructura y las responsabilidades de los componentes que comprenderán la Arquitectura de Software
      - __Validación:__ Significa “probar” la arquitectura, típicamente pasando a través del diseño contra los requerimientos actuales y cualquier posible requerimiento a futuro. 

      ---
      # Proceso de modelado de arquitectura de software 
      - __Definir los requerimientos:__
      ![RN](./media/requerimientos.png)

      ---
      # Proceso de modelado de arquitectura de software 

      __Definir los requerimientos (no funcionales):__
      
      - Describen cómo el software debe comportarse, es decir como hacer algo, no qué debe hacer
      - Están relacionados con los requerimientos funcionales porque describen la forma que se espera se logren dichos requerimientos
      - En algunos casos tienen restricciones de cómo hacerlo
      - Se clasifican de acuerdo al atributo de calidad esperado del sistema 
      
      ---
      # Proceso de modelado de arquitectura de software 

      __Definir los requerimientos (restricciones):__
      
      - Las restricciones (constraints) imponen condiciones sobre la arquitectura que normalmente no son negociables.
      - Limitan el rango de alternativas de decisión del arquitecto
      - Algunas veces hace la vida más fácil para el arquitecto, en otras lo complica.
      - Se pueden clasificar según su naturaleza: Negocio, Desarrollo, Tiempo, Costo, etc.

      ---
      # Proceso de modelado de arquitectura de software 
      
      __Ejemplos de requerimientos:__
      
      ![RN](./media/requerimientos01.png)

      ---
      # Proceso de modelado de arquitectura de software 
      
      __Ejemplos de restricciones:__
      
      ![RN](./media/restricciones.png)

      ---
      # Proceso de modelado de arquitectura de software

      __Priorización de requerimientos__
      - __Alta:__ La aplicación debe soportar el requerimiento. Estos requerimientos guían el diseño de la arquitectura
      - __Media:__ Requerimientos que necesitan ser soportados en algún momento o etapa del proyecto pero no necesariamente en esta siguiente versión.
      - __Baja:__ Se conoce como parte de la “wish-list”. Se pueden implementar cuando sea posible hacerlo. 

      ---
      # Proceso de modelado de arquitectura de software 
      
      __Diseño de la arquitectura:__

      ![RN](./media/diseno.png)

      ---
      # Proceso de modelado de arquitectura de software 
      
      __Escogencia de la arquitectura de Referencia :__

      - Discutir los posibles estilos y patrones más apropiados que den el soporte requerido para alcanzar los atributos de calidad deseados
      - Basarse en Arquitecturas de Referencia reconocidas tanto por la academia como por la industria que sean implementaciones conocidas, de amplia difusión y uso y muy buena documentación
      - Reconocer el tamaño de la aplicación objetivo
       - Aplicaciones pequeñas  -> Pocos patrones requeridos
       - Aplicaciones grandes  -> Mezcla de varios patrones

      ---
      # Proceso de modelado de arquitectura de software 
      
      __Asignación de componentes:__

      - Su objetivo es definir los componentes principales que comprenderán el diseño
      - La arquitectura de referencia define los patrones de comunicación en general para los componentes
      - Se busca además:
       - Identificar cómo los componentes se ajustan a los patrones
       - Identificar las interfaces y los servicios que cada componente soporta para así validar la asignación de responsabilidades de los componentes e Identificar dependencias entre ellos
       - Identificar las partes de la arquitectura candidatas a distribuirse en varios servidores.
       
      ---
      # Proceso de modelado de arquitectura de software

      __Guías para diseño de componentes:__
       
      - Minimizar dependencias entre componentes evitando propagar los cambios entre muchos componentes y por ende sus pruebas.
      - Diseñar componentes que encapsulan un alta cohesión del conjunto de responsabilidades. 
      - Aislar las dependencias con tecnologías Middleware y cualquier COTS. Esto facilita los cambios en el diseño de la AS. 
      - Usar la descomposición para estructurar componentes jerárquicamente: el componente más externo define la interfaz pública disponible e internamente los llamados a esa interfaz son delegados a otros componentes localmente definidos.
      - Reducir al mínimo las llamadas entre componentes, ya que pueden resultar costosas si los componentes se distribuyen (métodos de grano grueso o servicios en las interfaces que hacen más trabajo por cada requerimiento-invocación).

      ---
      # Proceso de modelado de arquitectura de software

      __Validación:__
      
      - Consiste en aumentar la confianza del equipo de diseño con respecto a que la arquitectura es adecuada para cumplir con los requerimientos del sistema. 
      - Se puede escoger entre dos técnicas: Pruebas manuales o Prototipos. 
       - Prueba manual: Involucra la prueba de la AS usando escenarios 
       - Prototipo: Involucra la construcción de un prototipo que crea un arquetipo de la aplicación deseada, de esta forma su capacidad para satisfacer las necesidades se pueden evaluar con más detalle a través de prototipos.
      
      ---
      template: inverse
      # Evolución de las arquitecturas de software
      ### de los monolitos a los servicios
        
      ---
      # Evolución
      ![mini](./media/evolucion01.png)
 
      ---
      # Evolución
      ![RN](./media/evolucion02.png)
 
      ---
      # Evolución
      ![intermedia](./media/evolucion03.png)
 
      ---
      # Arquitectura monolítica
      .text-column[
      __Monolítico:__
      - adj. Perteneciente o relativo al monolito.
      - adj. Que está hecho de una sola piedra.
      - adj. De una pieza, sin fisuras.
      - adj. Inconmovible, rígido, inflexible
      ]
      .img-column[
      ![RN](./media/monolito.png)
      ]
 
      ---
      # Arquitectura monolítica
 
      - Monolítico, en el contexto de software, significa compuesto todo de una pieza. 
      - El software monolítico está diseñado para ser autónomo; los componentes del programa están interconectados e interdependientes en lugar de estar débilmente acoplados, como es el caso de los programas de software modulares.
      - Dado su alto nivel de acoplamiento, cada componente y sus componentes asociados deben estar presentes para que el código sea ejecutado o compilado.
      - Si se debe actualizar cualquier componente del programa, se debe reescribir toda la aplicación.
      - Los sistemas monolíticos no están divididos en partes independientes, corren en una sola unidad de procesamiento
      - En su momento fueron la única elección ya que los computadores no hablaban mucho entre ellos.
 
      ---
      # Arquitectura monolítica
 
      - La ausencia de las comunicaciones complejas requería altos niveles de procesamiento y solo permitía escalabilidad vertical.
      - Estructura interna indefinida y niveles de funcionalidad no separados.
      - Típica e Históricamente, los sistemas monolíticos hablaban con clientes brutos. (terminales).
      - Un solo programa compuesto de un conjunto de rutinas entrelazadas a través del ligador con un alto acoplamiento.
      - Carecen de protecciones y privilegios al entrar a rutinas que manejan diferentes aspectos de los recursos como memoria, disco, etc.
      - No hay distribución, tanto a nivel físico ni a nivel lógico.
      Los programas monolíticos suelen tener un mejor rendimiento que los enfoques modulares y pueden ser más fáciles de probar y depurar porque, con menos elementos, hay menos variables que entran en juego.
      - Un monolito puede considerarse un estilo arquitectónico o un patrón de desarrollo de software (o anti-patrón visto de forma negativa).
       
      ---
      # Arquitectura monolítica
 
      __Módulo monolítico:__
       
      .text-column[
      - Todo el código de un sistema se encuentra en una única base de código compilada conjuntamente y que produce un solo artefacto.
      - El código aún puede estar bien estructurado (clases y paquetes coherentes y desacoplados) pero no se divide en módulos separados para la compilación. 
      - Existen ventajas y desventajas se hace principalmente para la administración del desarrollo.
      ]
      .img-column[
      ![RN](./media/modulo_monolitico.png)
      ]
 
      ---
      # Arquitectura monolítica
 
      __Monolito de asignación:__
       
      - Todo el código se envía / implementa al mismo tiempo. En otras palabras, una vez que el código compilado está “listo para su lanzamiento”, se envía una única versión a todos los nodos. 
      - Todos los componentes en ejecución tienen la misma versión del software ejecutándose en cualquier momento.
      .text-column[
      - Esto es independiente de si la estructura del módulo es un monolito. 
      - De cualquier forma, esta versión se implementa en todas partes a la vez (requiere detener todo el sistema, desplegar el software y luego reiniciar).
      ]
      .img-column[
      ![RN](./media/monolito_asignacion.png)
      ]
      ---
      # Arquitectura monolítica
 
      __Monolito de asignación:__
       
      ![intermedia](./media/monolito_asignacion.png)
 
      ---
      # Arquitectura monolítica
 
      __Monolito en tiempo de ejecución:__
       
      .text-column[
      - Tienen una única aplicación o proceso que realice el trabajo para el sistema.
      - Si el tiempo de ejecución es un monolito es independiente de si el código del sistema es un monolito de módulo o no. 
      - Un monolito de tiempo de ejecución a menudo implica un monolito de asignación si solo se implementa un nodo / componente principal 
      ]
      .img-column[
      ![RN](./media/monolito_ejecucion.png)
      ]
 
      ---
      # Arquitectura cliente / servidor
 
      - Consiste básicamente en un cliente que realiza peticiones a otro programa (el servidor) quien da respuesta. 
      - Aunque se puede aplicar a programas que se ejecutan sobre una sola computadora ofrece más ventajas en un sistema operativo multiusuario distribuido a través de una red de computadoras.
      - La capacidad de proceso está repartida entre los clientes y los servidores.
      - Ofrece ventajas de tipo organizativo debidas a la centralización de la gestión de la información y la separación de responsabilidades.
      - Facilita y clarifica el diseño del sistema.
      - La separación entre cliente y servidor es una separación de tipo lógico.
      - El servidor no se ejecuta necesariamente sobre una sola máquina ni es necesariamente un sólo programa. 
       
      ---
      # Arquitectura cliente / servidor
 
      .text-column[
      - Los tipos específicos de servidores incluyen los servidores web, los servidores de archivo, los servidores del correo, etc. 
      - Una disposición muy común son los sistemas multicapa en los que el servidor se descompone en diferentes programas que pueden ser ejecutados por diferentes computadoras aumentando así el grado de distribución del sistema.
      ]
      .img-column[
      ![RN](./media/cliente_servidor.png)
      ]
       
      ---
      # Arquitectura cliente / servidor
 
      __Cliente:__
      - Es quien inicia solicitudes o peticiones, tienen por tanto un papel activo en la comunicación (dispositivo maestro o amo).
      - Espera y recibe las respuestas del servidor.
      - Por lo general, puede conectarse a varios servidores a la vez.
      - Normalmente interactúa directamente con los usuarios finales mediante una interfaz gráfica de usuario.
 
      ---
      # Arquitectura cliente / servidor
 
      __Servidor:__
      - Al iniciarse esperan a que lleguen las solicitudes de los clientes, desempeñan entonces un papel pasivo en la comunicación (dispositivo esclavo).
      - Tras la recepción de una solicitud, la procesan y luego envían la respuesta al cliente.
      - Por lo general, aceptan conexiones desde un gran número de clientes (en ciertos casos el número máximo de peticiones puede estar limitado).
      - No es frecuente que interactúen directamente con los usuarios finales.
 
      ---
      # Arquitectura cliente / servidor
 
      __Clasificación arquitectura cliente / servidor__
       
      - Sistema de clasificación según tamaño de componentes.
       - Fat Client (Thin Server).
       - Fat Server (Thin Client).
      - Sistema de clasificación según planos o capas (Tier).
       - Planos a niveles de software.
       - Planos a niveles de hardware.
      - Clasificación según la naturaleza del servicio.
        - Servidores de bases de datos.
 
        
      ---
      # Arquitectura N-capas
 
      __Capas:__
       
      - Hace referencia a la forma como una solución es segmentada desde el punto de vista lógico, las capas son el mecanismo de estructuración lógica para los elementos que componen la solución del software.
 
      __Niveles:__
       
      - Corresponde a la forma en que las capas lógicas se encuentran distribuidas de forma física. Es un mecanismo para la estructuración de la infraestructura del sistema.
       
      ---
      # Arquitectura N-capas
 
      __Niveles y capas:__
 
      - Una solución de tres capas (presentación, lógica, datos) que residen en un solo ordenador (Presentación + lógica + datos). Se dice que la arquitectura de la solución es de ___tres capas y un nivel___. 
      - Una solución de tres capas (presentación, lógica, datos) que residen en dos ordenadores (presentación + lógica, lógica + datos). Se dice que la arquitectura de la solución es de ___tres capas y dos niveles___. 
      - Una solución de tres capas (presentación, lógica, datos) que residen en tres ordenadores (presentación, lógica, datos). La arquitectura que la define es: solución de ___tres capas y tres niveles___.
 
      ---
      # Arquitectura N-capas
 
      ![RN](./media/n_capas.png)
 
      ---
      # Arquitectura N-capas
 
      __Descripción:__
       
      - La N significa cualquier cantidad de capas, no hay límites.
      - Ayuda a simplificar, al enfrentamos a mezcla de aplicaciones, interfaces y las redes multiplataformas.
      - La cantidad de capas de software depende de las necesidades del negocio
      - Las capas se pueden distribuir en el hardware que sea necesario.
      - Presentan organizaciones Jerárquicas.
      - Cada capa resuelve una parte del problema.
      - Las capas se comunican mediante servicios.
      - Cada capa puede cambiar su implementación independiente de las otras capas
      - Los sistemas en capas más conocidos son las pilas de protocolos para comunicaciones y los sistemas operativos.
 
      ---
      # Arquitectura N-capas
 
      __Mecanismos, protocolos y estándares para la comunicación entre capas:__
      - ___CORBA___ (Common Object Request Broker Architecture) Arquitectura Común de Intermediarios en Peticiones a Objetos: es un estándar que facilita la invocación de métodos remotos bajo un paradigma orientado a objetos. 
      - ___DCOM___ (Distributed Component Object Model) Modelo de Objetos de Componentes Distribuidos, es una tecnología propietaria de Microsoft para desarrollar componentes software distribuidos.
      - ___RMI___ (Java Remote Method Invocation) es un mecanismo ofrecido en Java para invocar un método remotamente. 
      - ___SOAP___ (Simple Object Access Protocol) es un protocolo estándar que define cómo dos objetos en diferentes procesos pueden comunicarse por medio de intercambio de datos XML 
      - ___Web Services___: es un conjunto de protocolos y estándares que sirven para intercambiar datos entre aplicaciones.
 
      ---
      # Arquitectura N-capas
 
      __Ventajas:__
      - Administrabilidad
      - Reutilización de capas
      - Facilidad en la estandarización 
      - Las dependencias se limitan a intra-capa 
      - Contención de cambios a una o pocas capas
      - Centralización del control
      - Escalabilidad
      - Fácil mantenimiento
      - Existencia de tecnologías con soporte a desarrollo de n-capas
      - Extensibilidad
      - Seguridad
 
      ---
      # Arquitectura N-capas
 
      __Desventajas:__
       
      - Posible pérdida en la contención del cambio
      - Pérdida de eficiencia (redundancia)‏
      - Dificultad de diseñar correctamente la granularidad de las capas. 
      - Aumento de la complejidad. 
      - Problemas de comunicaciones (congestión del tráfico).
      - Costos de Mantenimiento. 
 
      ---
      # Arquitectura Orientada a Servicios
 
      __Definiciones:__
 
      - ___W3C:___ “Conjunto de componentes que pueden ser invocados, cuyas descripciones de interfaces se pueden publicar y descubrir”
      - ___SEI:___ “Estilo resultante de políticas, prácticas y frameworks que permiten que la funcionalidad de una aplicación se pueda proveer y consumir como conjuntos de servicios, con una granularidad relevante para el consumidor. Los servicios pueden invocarse, publicarse y descubrirse y están abstraídos de su implementación utilizando una sola forma estándar de interface”.
      - ___IBM:___ “Una arquitectura de aplicación en la cual todas las funciones se definen como servicios independientes con interfaces invocables bien definidas, que pueden ser llamadas en secuencias definidas para formar procesos de negocios”.
            
      ---
      # Arquitectura Orientada a Servicios
 
      SOA es un estilo de arquitectura que promueve descomponer la lógica funcional de una aplicación en unidades autónomas denominadas servicios
 
      - ___Operación:___ Unidad de trabajo o procesamiento en una arquitectura SOA.
      - ___Servicio:___ Contenedor de lógica. Compuesto por un conjunto de operaciones, las cuales ofrecerá a sus usuarios.
      - ___Mensaje:___ Encargados de encapsular los datos de entrada y de salida.
      - ___Proceso de negocio:___ Conjunto de operaciones ejecutada en una determinada secuencia con el objetivo de realizar una determinada tarea.
 
      ---
      # Arquitectura Orientada a Servicios
 
      __Servicios:__
       
      > “Una aplicación SOA está formada por un conjunto de servicios interconectados cuyo objetivo es automatizar uno o varios procesos de negocio".
 
      ![RN](./media/servicios01.png)
 
      ---
      # Arquitectura Orientada a Servicios
 
      __Principios:__
 
      ![RN](./media/servicios02.png)
 
      ---
      # Arquitectura Orientada a Servicios
 
      - SOA es un estilo arquitectónico para la construcción de aplicaciones de software en base a servicios disponibles. 
      - Es un paradigma para organizar y utilizar capacidades distribuidas y bajo el control de diferentes propietarios y dominios.
      - Topología de software, que consiste de servicios y consumidores de servicios en una relación débilmente acoplada. 
      - Las capacidades del Negocio y los Procesos del negocio, serán modelados como servicios.
      - Provee una manera uniforme de ofrecer, descubrir, interactuar y usar dichas capacidades para producir los efectos deseados de manera consistente y medible.
      - Arquitectura conceptual.
       
      ---
      # Arquitectura Orientada a Servicios
 
      - Organiza funciones de negocio como servicio interoperables.
      - Permite reutilización de servicios para satisfacer necesidades de negocio.
      - Es basado en estándares.
      - Estrategia de tecnologías de información a nivel empresarial.
      - Esconde detalles internos (Plataforma, Lenguaje de programación, lógica que ejecuta los procesos, almacenamiento).
      - Los servicios encapsulan procesos de negocios.
      - Esta en capacidad de involucrar diferentes tecnologías y representa mejor la integración de las mismas.
      - Todos los servicios son independientes, operan como cajas negras. Los componentes externos no conocen ni les interesa como desempeñan su función, solo que entreguen el resultado esperado.
       
      ---
      # Arquitectura Orientada a Servicios
 
      __Componentes:__
 
      ![intermedia](./media/soa01.png)
 
      ---
      # Arquitectura Orientada a Servicios
 
      __Dinámica:__
 
      ![intermedia](./media/soa02.png)
 
      ---
      # Arquitectura Orientada a Servicios
 
      __Niveles de servicio:__
 
      - ___Servicios de Aplicación___ (Application Services): Sirven como base para la creación de servicios de negocio.
      - ___Servicios de Negocio___ (Business Services): Expresan la lógica del negocio. 
      - ___Servicios de Orquestación___ (Orchestration Services): Consisten en servicios de proceso compuestos por business services y application services coordinados mediante reglas de negocio y secuencias de ejecución.
 
      ---
      # Arquitectura Orientada a Servicios
 
      __Estándares SOA:__
      .text-column[
      - ___XML:___ Extensible Markup Language
      - ___SOAP:___ Protocolo de Mensajeria.
      - ___WSDL:___ Definición de la interfaz.
      - ___UDDI___ y ___ebXML:___ Capacidades de localización.
      - ___WS-Security___, ___WS-BPEL___
      - ___HTTP:___ Mecanismo de transporte.
      ]
      .img-column[
      ![RN](./media/soa03.png)
      ]
 
      ---
      # Arquitectura Orientada a Servicios
 
      __Ventajas:__
      - Ayuda a mejorar la agilidad y flexibilidad de las organizaciones.
      - Permite simplificación del desarrollo de soluciones mediante la utilización de estándares de la industria y capacidades comunes de industrialización.
      - Permite alinear y acercar la áreas de tecnología y de negocio.
      - Permite aislar mejor a los sistemas frente a los cambios generados por otras partes de la organización.
 
      __Desventajas:__
      - SOA requiere un cambio en las organizaciones, un alto esfuerzo
      - Elimina progresos que la historia de los paradigmas suelen resolver paso a paso, tales como el rendimiento o la integridad de la información. 
 
      ---
      # Arquitecturas basadas en microservicios
       
      ## ¿Qué son los microservicios?
 
      - La arquitectura orientada a microservicios es un estilo arquitectónico en el cual una aplicación compleja está compuesta de pequeños servicios independientes que se comunican entre sí usando APIs agnósticas. 
      - Estos servicios son pequeños, altamente desacoplados y enfocados en pequeñas tareas. 
      - La arquitectura de microservicios permite la entrega / despliegue continuo de aplicaciones grandes y complejas.
 
      ---
      # Arquitecturas basadas en microservicios
 
      ## Monolítico vs Microservicios
 
      ![RN](./media/micro_servicios01.png)
 
      ---
      # Arquitecturas basadas en microservicios
 
      ## Monolítico vs Microservicios
 
      ![RN](./media/micro_servicios02.png)
 
      ---
      # Arquitecturas basadas en microservicios
 
      ## Monolítico vs Microservicios
 
      ![RN](./media/micro_servicios03.png)
 
      ---
      # Arquitecturas basadas en microservicios
 
      ## Beneficios de los microservicios
 
      ___Responsabilidad única:___ una única tarea por microservicio
 
      ![RN](./media/micro_servicios04.png)
 
      ---
      # Arquitecturas basadas en microservicios
 
      ## Beneficios de los microservicios
 
      ___Desarrollo eficiente:___ microservicios pequeños y especializados
 
      ![RN](./media/micro_servicios05.png)
 
      ---
      # Arquitecturas basadas en microservicios
 
      ## Beneficios de los microservicios
 
      ___Escalado eficiente, elástico y horizontal:___ basado en la demanda
 
      ![RN](./media/micro_servicios06.png)
 
      ---
      # Arquitecturas basadas en microservicios
 
      ## Beneficios de los microservicios
 
      ___Políglota:___ los microservicios puede estar desarrollado en plataformas diferentes
 
      ![RN](./media/micro_servicios07.png)
 
      ---
      # Arquitecturas basadas en microservicios
 
      ## Beneficios de los microservicios
 
      ___Despliegue independiente:___ los microservicios se despliegan de forma independiente
 
      ![RN](./media/micro_servicios08.png)
 
      ---
      # Arquitecturas basadas en microservicios
 
      ## Características de la arquitectura
 
      - Los componentes son servicios.
      - Organizada en torno a las funcionalidades del negocio.
      - Productos no proyectos.
      - Extremos inteligentes tuberías bobas.
      - Tener gobierno descentralizado permite usar tecnologías que se adapten mejor a cada funcionalidad.
      - Gestión de datos descentralizada.
      - Diseño pensado en las fallas.
      - Automatización de la infraestructura.
      - Diseño evolutivo.
       
      ---
      # Arquitecturas basadas en microservicios
 
      ## ¿Qué necesito para microservicios?
 
      ![reducida](./media/micro_servicios09.png)
 
      ---
      # Arquitecturas basadas en microservicios
 
      ## ¿Qué necesito para microservicios?
 
      ___Servidor de configuración central___
      - Se encargará de centralizar y proveer remotamente la configuración a cada microservicio. Esta configuración se mantiene convencionalmente en un repositorio Git, lo que nos permitirá gestionar su propio ciclo de vida y versionado.
       
      ___Servicio de registro / descubrimiento___
      - Será el encargado de proveer los endpoints de los servicios para su consumo. Todo microservicio se registrará automáticamente en él en tiempo de bootstrap.
 
      ---
      # Arquitecturas basadas en microservicios
 
      ## ¿Qué necesito para microservicios?
 
      ___Balanceo de carga (Load balancer)___
      - Permite el balanceo entre distintas instancias de forma transparente a la hora de consumir un servicio.
       
      ___Tolerancia a fallos (Circuit breaker)___
      - Permite que cuando se produzca un fallo, este no se propague en cascada por todo el pipe de llamadas, y poder gestionar el error de forma controlada a nivel local del servicio donde se produjo.
 
      ___Servidor perimetral / exposición de servicios (Edge server)___
      - Será un gateway en el que se expondrán los servicios a consumir.
       
      ---
      # Arquitecturas basadas en microservicios
 
      ## ¿Qué necesito para microservicios?
 
      ___Centralización de logs___
      - Se hace necesario un mecanismo para centralizar la gestión de logs. Sería inviable la consulta de cada log individual de cada uno de los microservicios.
       
      ___Servidor de Autorización___
      - Para implementar la capa de seguridad (recomendable en la capa de servicios API)
 
      ___Monitorización___
      - Es interesante el poder disponer de mecanismos y algún dashboard para monitorizar aspectos de los nodos como, salud, carga de trabajo.
       
      ---
      # Arquitecturas basadas en microservicios
 
      ## Stacks tecnológicos reconocidos
 
      - Docker – http://www.docker.io
      - Amazon Web Services (AWS) – http://amazon.com
      - Eureka (Servicio de descubrimiento) – https://github.com/Netflix/eureka
      - Ribbon (Balanceador de carga en cliente)- https://github.com/Netflix/ribbon
      - Hystrix (Circuit Breaker y Monitorización) – https://github.com/Netflix/Hystrix
      - Zuul (Edge/Proxy Server , con enrutado dinámico, monitorización, capacidad de recuperación, seguridad, etc…) – https://github.com/Netflix/zuul
      - Spring Cloud Config (Configuración distribuida) – http://cloud.spring.io/spring-cloud-config/
      - Archaius (Configuración distribuida con cambios en caliente) – https://github.com/Netflix/archaius
       
      ---
      # Arquitecturas basadas en microservicios
 
      ## Buenas prácticas relacionadas
 
      - Evitar congestiones de tráfico haciendo hincapié en el cacheo de las peticiones a microservicios de alto uso.
      - Implementar y adherirse a las prácticas culturales de DevOps. Los recursos de desarrollo necesitarán su propio camino hasta producción para sus cambios.
      - Pasar los datos vía http headers cuando sea posible para reducir congestiones de tráfico entre microservicios.
      - Implementar el patrón “Circuit Breaker” para evitar fallos en cadena y hacer al sistema más tolerante a fallos.
      - Usar un servicio de mensajería basado en colas tal como RabbitMQ, OpenMQ, etc… cuando sea posible.
 
      ---
      # Arquitecturas basadas en microservicios
 
      ## Buenas prácticas relacionadas
 
      - Des-sincronizar todo lo posible para incrementar el rendimiento.
      - Implementar protocolos de restricción de acceso para reducir la disponibilidad de los microservicios a aquellos que no deben llamarlos.
      - Usar soluciones de descubrimiento de servicios para que la arquitectura pueda dinámicamente expandirse o contraerse sin la intervención de un agente de gobierno.
      - Esperar lo inesperado.
       
 
 
       
    </textarea>
    <script src="scripts/remark.js"></script>
    <script>
       var slideshow = remark.create();
    </script>
  </body>
</html>
